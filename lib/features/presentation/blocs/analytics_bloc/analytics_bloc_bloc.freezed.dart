// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analytics_bloc_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$AnalyticsBlocEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAnaliytics,
    required TResult Function(DateTime month) getMonthlyAnalytics,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAnaliytics,
    TResult? Function(DateTime month)? getMonthlyAnalytics,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAnaliytics,
    TResult Function(DateTime month)? getMonthlyAnalytics,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loadanaliytics value) loadAnaliytics,
    required TResult Function(_GetMonthlyAnalytics value) getMonthlyAnalytics,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loadanaliytics value)? loadAnaliytics,
    TResult? Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loadanaliytics value)? loadAnaliytics,
    TResult Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticsBlocEventCopyWith<$Res> {
  factory $AnalyticsBlocEventCopyWith(
    AnalyticsBlocEvent value,
    $Res Function(AnalyticsBlocEvent) then,
  ) = _$AnalyticsBlocEventCopyWithImpl<$Res, AnalyticsBlocEvent>;
}

/// @nodoc
class _$AnalyticsBlocEventCopyWithImpl<$Res, $Val extends AnalyticsBlocEvent>
    implements $AnalyticsBlocEventCopyWith<$Res> {
  _$AnalyticsBlocEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalyticsBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadanaliyticsImplCopyWith<$Res> {
  factory _$$LoadanaliyticsImplCopyWith(
    _$LoadanaliyticsImpl value,
    $Res Function(_$LoadanaliyticsImpl) then,
  ) = __$$LoadanaliyticsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadanaliyticsImplCopyWithImpl<$Res>
    extends _$AnalyticsBlocEventCopyWithImpl<$Res, _$LoadanaliyticsImpl>
    implements _$$LoadanaliyticsImplCopyWith<$Res> {
  __$$LoadanaliyticsImplCopyWithImpl(
    _$LoadanaliyticsImpl _value,
    $Res Function(_$LoadanaliyticsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AnalyticsBlocEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadanaliyticsImpl implements _Loadanaliytics {
  const _$LoadanaliyticsImpl();

  @override
  String toString() {
    return 'AnalyticsBlocEvent.loadAnaliytics()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadanaliyticsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAnaliytics,
    required TResult Function(DateTime month) getMonthlyAnalytics,
  }) {
    return loadAnaliytics();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAnaliytics,
    TResult? Function(DateTime month)? getMonthlyAnalytics,
  }) {
    return loadAnaliytics?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAnaliytics,
    TResult Function(DateTime month)? getMonthlyAnalytics,
    required TResult orElse(),
  }) {
    if (loadAnaliytics != null) {
      return loadAnaliytics();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loadanaliytics value) loadAnaliytics,
    required TResult Function(_GetMonthlyAnalytics value) getMonthlyAnalytics,
  }) {
    return loadAnaliytics(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loadanaliytics value)? loadAnaliytics,
    TResult? Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
  }) {
    return loadAnaliytics?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loadanaliytics value)? loadAnaliytics,
    TResult Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
    required TResult orElse(),
  }) {
    if (loadAnaliytics != null) {
      return loadAnaliytics(this);
    }
    return orElse();
  }
}

abstract class _Loadanaliytics implements AnalyticsBlocEvent {
  const factory _Loadanaliytics() = _$LoadanaliyticsImpl;
}

/// @nodoc
abstract class _$$GetMonthlyAnalyticsImplCopyWith<$Res> {
  factory _$$GetMonthlyAnalyticsImplCopyWith(
    _$GetMonthlyAnalyticsImpl value,
    $Res Function(_$GetMonthlyAnalyticsImpl) then,
  ) = __$$GetMonthlyAnalyticsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateTime month});
}

/// @nodoc
class __$$GetMonthlyAnalyticsImplCopyWithImpl<$Res>
    extends _$AnalyticsBlocEventCopyWithImpl<$Res, _$GetMonthlyAnalyticsImpl>
    implements _$$GetMonthlyAnalyticsImplCopyWith<$Res> {
  __$$GetMonthlyAnalyticsImplCopyWithImpl(
    _$GetMonthlyAnalyticsImpl _value,
    $Res Function(_$GetMonthlyAnalyticsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AnalyticsBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? month = null}) {
    return _then(
      _$GetMonthlyAnalyticsImpl(
        null == month
            ? _value.month
            : month // ignore: cast_nullable_to_non_nullable
                  as DateTime,
      ),
    );
  }
}

/// @nodoc

class _$GetMonthlyAnalyticsImpl implements _GetMonthlyAnalytics {
  const _$GetMonthlyAnalyticsImpl(this.month);

  @override
  final DateTime month;

  @override
  String toString() {
    return 'AnalyticsBlocEvent.getMonthlyAnalytics(month: $month)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetMonthlyAnalyticsImpl &&
            (identical(other.month, month) || other.month == month));
  }

  @override
  int get hashCode => Object.hash(runtimeType, month);

  /// Create a copy of AnalyticsBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GetMonthlyAnalyticsImplCopyWith<_$GetMonthlyAnalyticsImpl> get copyWith =>
      __$$GetMonthlyAnalyticsImplCopyWithImpl<_$GetMonthlyAnalyticsImpl>(
        this,
        _$identity,
      );

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadAnaliytics,
    required TResult Function(DateTime month) getMonthlyAnalytics,
  }) {
    return getMonthlyAnalytics(month);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadAnaliytics,
    TResult? Function(DateTime month)? getMonthlyAnalytics,
  }) {
    return getMonthlyAnalytics?.call(month);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadAnaliytics,
    TResult Function(DateTime month)? getMonthlyAnalytics,
    required TResult orElse(),
  }) {
    if (getMonthlyAnalytics != null) {
      return getMonthlyAnalytics(month);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loadanaliytics value) loadAnaliytics,
    required TResult Function(_GetMonthlyAnalytics value) getMonthlyAnalytics,
  }) {
    return getMonthlyAnalytics(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loadanaliytics value)? loadAnaliytics,
    TResult? Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
  }) {
    return getMonthlyAnalytics?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loadanaliytics value)? loadAnaliytics,
    TResult Function(_GetMonthlyAnalytics value)? getMonthlyAnalytics,
    required TResult orElse(),
  }) {
    if (getMonthlyAnalytics != null) {
      return getMonthlyAnalytics(this);
    }
    return orElse();
  }
}

abstract class _GetMonthlyAnalytics implements AnalyticsBlocEvent {
  const factory _GetMonthlyAnalytics(final DateTime month) =
      _$GetMonthlyAnalyticsImpl;

  DateTime get month;

  /// Create a copy of AnalyticsBlocEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GetMonthlyAnalyticsImplCopyWith<_$GetMonthlyAnalyticsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnalyticsBlocState {
  Failure get failure => throw _privateConstructorUsedError;
  Status get status => throw _privateConstructorUsedError;
  double get income => throw _privateConstructorUsedError;
  double get expense => throw _privateConstructorUsedError;
  double get balance => throw _privateConstructorUsedError;
  Map<String, double> get monthlyData => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )
    initial,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )?
    initial,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )?
    initial,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) => throw _privateConstructorUsedError;

  /// Create a copy of AnalyticsBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnalyticsBlocStateCopyWith<AnalyticsBlocState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticsBlocStateCopyWith<$Res> {
  factory $AnalyticsBlocStateCopyWith(
    AnalyticsBlocState value,
    $Res Function(AnalyticsBlocState) then,
  ) = _$AnalyticsBlocStateCopyWithImpl<$Res, AnalyticsBlocState>;
  @useResult
  $Res call({
    Failure failure,
    Status status,
    double income,
    double expense,
    double balance,
    Map<String, double> monthlyData,
  });
}

/// @nodoc
class _$AnalyticsBlocStateCopyWithImpl<$Res, $Val extends AnalyticsBlocState>
    implements $AnalyticsBlocStateCopyWith<$Res> {
  _$AnalyticsBlocStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalyticsBlocState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failure = null,
    Object? status = null,
    Object? income = null,
    Object? expense = null,
    Object? balance = null,
    Object? monthlyData = null,
  }) {
    return _then(
      _value.copyWith(
            failure: null == failure
                ? _value.failure
                : failure // ignore: cast_nullable_to_non_nullable
                      as Failure,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as Status,
            income: null == income
                ? _value.income
                : income // ignore: cast_nullable_to_non_nullable
                      as double,
            expense: null == expense
                ? _value.expense
                : expense // ignore: cast_nullable_to_non_nullable
                      as double,
            balance: null == balance
                ? _value.balance
                : balance // ignore: cast_nullable_to_non_nullable
                      as double,
            monthlyData: null == monthlyData
                ? _value.monthlyData
                : monthlyData // ignore: cast_nullable_to_non_nullable
                      as Map<String, double>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res>
    implements $AnalyticsBlocStateCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
    _$InitialImpl value,
    $Res Function(_$InitialImpl) then,
  ) = __$$InitialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    Failure failure,
    Status status,
    double income,
    double expense,
    double balance,
    Map<String, double> monthlyData,
  });
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$AnalyticsBlocStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
    _$InitialImpl _value,
    $Res Function(_$InitialImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AnalyticsBlocState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failure = null,
    Object? status = null,
    Object? income = null,
    Object? expense = null,
    Object? balance = null,
    Object? monthlyData = null,
  }) {
    return _then(
      _$InitialImpl(
        failure: null == failure
            ? _value.failure
            : failure // ignore: cast_nullable_to_non_nullable
                  as Failure,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as Status,
        income: null == income
            ? _value.income
            : income // ignore: cast_nullable_to_non_nullable
                  as double,
        expense: null == expense
            ? _value.expense
            : expense // ignore: cast_nullable_to_non_nullable
                  as double,
        balance: null == balance
            ? _value.balance
            : balance // ignore: cast_nullable_to_non_nullable
                  as double,
        monthlyData: null == monthlyData
            ? _value._monthlyData
            : monthlyData // ignore: cast_nullable_to_non_nullable
                  as Map<String, double>,
      ),
    );
  }
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl({
    this.failure = const UnknownFailure(),
    this.status = Status.initial,
    this.income = 0,
    this.expense = 0,
    this.balance = 0,
    final Map<String, double> monthlyData = const {},
  }) : _monthlyData = monthlyData;

  @override
  @JsonKey()
  final Failure failure;
  @override
  @JsonKey()
  final Status status;
  @override
  @JsonKey()
  final double income;
  @override
  @JsonKey()
  final double expense;
  @override
  @JsonKey()
  final double balance;
  final Map<String, double> _monthlyData;
  @override
  @JsonKey()
  Map<String, double> get monthlyData {
    if (_monthlyData is EqualUnmodifiableMapView) return _monthlyData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_monthlyData);
  }

  @override
  String toString() {
    return 'AnalyticsBlocState.initial(failure: $failure, status: $status, income: $income, expense: $expense, balance: $balance, monthlyData: $monthlyData)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InitialImpl &&
            (identical(other.failure, failure) || other.failure == failure) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.income, income) || other.income == income) &&
            (identical(other.expense, expense) || other.expense == expense) &&
            (identical(other.balance, balance) || other.balance == balance) &&
            const DeepCollectionEquality().equals(
              other._monthlyData,
              _monthlyData,
            ));
  }

  @override
  int get hashCode => Object.hash(
    runtimeType,
    failure,
    status,
    income,
    expense,
    balance,
    const DeepCollectionEquality().hash(_monthlyData),
  );

  /// Create a copy of AnalyticsBlocState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      __$$InitialImplCopyWithImpl<_$InitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )
    initial,
  }) {
    return initial(failure, status, income, expense, balance, monthlyData);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )?
    initial,
  }) {
    return initial?.call(
      failure,
      status,
      income,
      expense,
      balance,
      monthlyData,
    );
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(
      Failure failure,
      Status status,
      double income,
      double expense,
      double balance,
      Map<String, double> monthlyData,
    )?
    initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(failure, status, income, expense, balance, monthlyData);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements AnalyticsBlocState {
  const factory _Initial({
    final Failure failure,
    final Status status,
    final double income,
    final double expense,
    final double balance,
    final Map<String, double> monthlyData,
  }) = _$InitialImpl;

  @override
  Failure get failure;
  @override
  Status get status;
  @override
  double get income;
  @override
  double get expense;
  @override
  double get balance;
  @override
  Map<String, double> get monthlyData;

  /// Create a copy of AnalyticsBlocState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$InitialImplCopyWith<_$InitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
